/** @param {NS} ns **/
export async function main(ns) {
	var bufferMoney = 200000;
	var numHacknetProductionPercent = 0.25;
	var numSleepInterval = 10;
	var numSleepTimeMax = 3600000;
	var referenceNode = 0;
	var numMaxNodes = 32;

	//a better way to do this would be to calculate the return per
	//dollar investment and purchase based on the best return
	//unfortunately there is not a simple way to calculate that
	//return, despite it being shown in the Hacknet screen...
	//
	//I would have to reverse-engineer the formula used to
	//calculate the return for a given upgrade

	if (ns.args.length > 0) {
		if (ns.args[0] >= 0) {
			bufferMoney = ns.args[0];
		}
	}

	if (ns.args.length > 1) {
		if (ns.args[1] >= 0) {
			numHacknetProductionPercent = ns.args[1];
		}

		if (numHacknetProductionPercent > 1) {
			numHacknetProductionPercent = 1;
		}
	}

	if (ns.args.length > 2) {
		if (ns.args[2] > 0) {
			numMaxNodes = ns.args[2];
		}

		if (numMaxNodes > 64) {
			numMaxNodes = 64;
		}
	}

	function calculateLevelUpgradeProfit () {
		ns.print("calculateLevelUpgradeProfit()");
		var retVar = 0;

		//

		return retVar;
	}

	function findMinInArray (arr) {
		ns.print("findMinInArray()");
		var retVar = 0;
		var lowestNumber = arr[0];

		for (var i = 0; i < arr.length; i++) {
			if (arr[i] < lowestNumber) {
				lowestNumber = arr[i];
				retVar = i;
			}
		}

		return retVar;
	}

	function getWaitTime (numUpgradeCost) {
//		ns.print("getWaitTime()");
		var retVal = 0;

		if (numUpgradeCost > 0) {
			//a somewhat naive calculation, but should be close enough
			retVal = (numUpgradeCost / ((ns.hacknet.getNodeStats(referenceNode).production * ns.hacknet.numNodes()) * (1 / numHacknetProductionPercent)));
			retVal = Math.ceil(retVal);
			retVal *= 1000;
			retVal += 1000;

			if (retVal < 0) {
				retVal = 0;
			}

			if (retVal > numSleepTimeMax) {
				retVal = numSleepTimeMax;
			}
		}

		return retVal;
	}

	while (true) {
		if (ns.hacknet.numNodes() <= 0) {
			ns.print("there are currently no nodes in the hacknet");

			if (ns.hacknet.getPurchaseNodeCost() <= (ns.getServerMoneyAvailable("home") - bufferMoney)) {
				ns.hacknet.purchaseNode();
			}
		}

		//get / keep everything in sync
		for (var i = 1; i < ns.hacknet.numNodes(); i++) {
			while (ns.hacknet.getNodeStats(i).level < ns.hacknet.getNodeStats(referenceNode).level) {
				if (ns.hacknet.getLevelUpgradeCost(i, 1) < (ns.getServerMoneyAvailable("home") - bufferMoney)) {
					ns.hacknet.upgradeLevel(i, 1);
				}
				else {
					await ns.sleep(getWaitTime((ns.hacknet.getLevelUpgradeCost(i, 1) - (ns.getServerMoneyAvailable("home") - bufferMoney))));
				}
			}

			while (ns.hacknet.getNodeStats(i).ram < ns.hacknet.getNodeStats(referenceNode).ram) {
				if (ns.hacknet.getRamUpgradeCost(i, 1) < (ns.getServerMoneyAvailable("home") - bufferMoney)) {
					ns.hacknet.upgradeRam(i, 1);
				}
				else {
					await ns.sleep(getWaitTime((ns.hacknet.getRamUpgradeCost(i, 1) - (ns.getServerMoneyAvailable("home") - bufferMoney))));
				}
			}

			while (ns.hacknet.getNodeStats(i).cores < ns.hacknet.getNodeStats(referenceNode).cores) {
				if (ns.hacknet.getCoreUpgradeCost(i, 1) < (ns.getServerMoneyAvailable("home") - bufferMoney)) {
					ns.hacknet.upgradeCore(i, 1);
				}
				else {
					await ns.sleep(getWaitTime((ns.hacknet.getCoreUpgradeCost(i, 1) - (ns.getServerMoneyAvailable("home") - bufferMoney))));
				}
			}
		}

		//costs[0] == new node
		//costs[1] == level
		//costs[2] == ram
		//costs[3] == cores
		var costs = [
			ns.hacknet.getPurchaseNodeCost(),
			(ns.hacknet.getLevelUpgradeCost(referenceNode, 1) * ns.hacknet.numNodes()),
			(ns.hacknet.getRamUpgradeCost(referenceNode, 1) * ns.hacknet.numNodes()),
			(ns.hacknet.getCoreUpgradeCost(referenceNode, 1) * ns.hacknet.numNodes())
		];

		if (ns.hacknet.numNodes() >= numMaxNodes) {
			costs[0] = Infinity;
		}

		var cheapestOption = findMinInArray(costs);

		ns.print("costs[0]: " + costs[0]);
		ns.print("costs[1]: " + costs[1]);
		ns.print("costs[2]: " + costs[2]);
		ns.print("costs[3]: " + costs[3]);
		ns.print("the cheapest option is costs[" + cheapestOption + "]");

		if (costs[cheapestOption] == Infinity) {
			ns.print("no more upgrades available");
			break;
		}

		//The best I have come up with to optimize earning rate is rather complicated,
		//but basically it would be to generate the cost of the next upgrade for each option,
		//then to generate the cost of the second upgrade for that same option.
		//
		//The next step would be to calculate the time to purchase the next upgrade for each
		//option, then to calculate the opportunity cost for each option (compared to each
		//other option). Basically, this would be the time to purchase for a given option
		//minus the time to purchase for the other options (where time to purchase for
		//evaluated option is less than for the given option), multiplied by the future
		//earning power for the evaluated option minus the current earning power (the
		//difference with the evaluated option). For each option, there could be multiple
		//different opportunity costs as compared to each other option. We could call this
		//"immediate opportunity cost".
		//
		//The third step would be to calculate the cost for the next cheapest upgrade (ie,
		//looking one step into the future), which would require two sets of calculations.
		//The first would be to calculate the cost of the next upgrade for that option
		//(theoretically, the cost of two levels of upgrade minus the cost of a single
		//level of upgrade). The second set of calculations would be to compare the
		//cheapest option from the first set to any of the remaining options (ie, it may
		//be cheaper to purchase an upgrade in level now, but that the current cost of a
		//RAM upgrade would then be cheaper than any of the next upgrade options [ie, 2
		//levels of upgrade minus one level of upgrade]). This means the next cheapest
		//upgrade could be different for each upgrade option.
		//
		//Once the next cheapest upgrade for each option is known, the new earn rate for
		//each (current) upgrade option would need to be calculated, then the time it
		//would take to purchase the next upgrade. The total earnings for the other
		//upgrade options within that time could then be calculated. We could call this
		//"deferred opportunity cost".
		//
		//The last step would be to evaluate the two sets of opportunity costs. It could
		//be possible to have an option with higher immediate opportunity costs, but
		//lower deferred opportunity costs (ie, costs a little more now, but earns more
		//faster).
		//
		//In essence, I think the best option would be the one to get us to the next
		//upgrade the fastest.

		//a little bit of trickery to optimize the process of purchasing the selected
		//upgrade
		if (cheapestOption == 1) {
			costs[cheapestOption] = ns.hacknet.getLevelUpgradeCost(referenceNode, 1);
		}
		else if (cheapestOption == 2) {
			costs[cheapestOption] = ns.hacknet.getRamUpgradeCost(referenceNode, 1);
		}
		else if (cheapestOption == 3) {
			costs[cheapestOption] = ns.hacknet.getCoreUpgradeCost(referenceNode, 1);
		}

		while (costs[cheapestOption] > (ns.getServerMoneyAvailable("home") - bufferMoney)) {
			await ns.sleep(getWaitTime(costs[cheapestOption]));
		}

		if (costs[cheapestOption] <= (ns.getServerMoneyAvailable("home") - bufferMoney)) {
			if (cheapestOption == 0) {
				ns.print("purchasing a new node");
				ns.hacknet.purchaseNode();
			}
			else if (cheapestOption == 1) {
				ns.print("purchasing level upgrade");
				ns.hacknet.upgradeLevel(referenceNode, 1);
			}
			else if (cheapestOption == 2) {
				ns.print("purchasing ram upgrade");
				ns.hacknet.upgradeRam(referenceNode, 1);
			}
			else if (cheapestOption == 3) {
				ns.print("purchasing core upgrade");
				ns.hacknet.upgradeCore(referenceNode, 1);
			}
		}

		//to prevent an error
		await ns.sleep(numSleepInterval);
	}
}