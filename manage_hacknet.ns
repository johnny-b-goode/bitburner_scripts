/** @param {NS} ns **/
export async function main(ns) {
	var bufferMoney = 200000;
	var numHacknetProductionPercent = 0.25;
	var numSleepInterval = 10000;
	var numSleepTimeMax = 3600000;
	var referenceNode = 0;
	var numMaxNodes = 32;

	//a better way to do this would be to calculate the return per
	//dollar investment and purchase based on the best return
	//unfortunately there is not a simple way to calculate that
	//return, despite it being shown in the Hacknet screen...
	//
	//I would have to reverse-engineer the formula used to
	//calculate the return for a given upgrade

	if (ns.args.length > 0) {
		if (ns.args[0] >= 0) {
			bufferMoney = ns.args[0];
		}
	}

	//0 == new node
	//1 == level
	//2 == ram
	//3 == cores
	function levelUpgradeProfitDeltaPerSec (numUpgradeType) {
		ns.print("calculateLevelUpgradeProfit()");

		if ((numUpgradeType != 0)
			&& (numUpgradeType != 1)
			&& (numUpgradeType != 2)
			&& (numUpgradeType != 3)
			) {
			ns.print("	ERROR invalid value for numUpgradeType");
		}

		var retVar = 0;
		var nodeStats = ns.hacknet.getNodeStats(referenceNode);
		var numCurrentRate = 0;
		var numFutureRate = 0;

		if (ns.fileExists("Formulas.exe", "home")) {
			//https://github.com/danielyxie/bitburner/blob/dev/markdown/bitburner.hacknetnodesformulas.moneygainrate.md
			numCurrentRate = ns.formulas.calculateMoneyGainRate(nodeStats.level, nodeStats.ram, nodeStats.cores, ns.getHacknetMultipliers().production);

			if (numUpgradeType == 0) {
				numFutureRate = ns.formulas.calculateMoneyGainRate(1, 1, 1, ns.getHacknetMultipliers().production);
				retVar = numFutureRate;
			}
			else if (numUpgradeType == 1) {
				numFutureRate = ns.formulas.calculateMoneyGainRate((nodeStats.level + 1), nodeStats.ram, nodeStats.cores, ns.getHacknetMultipliers().production);
				retVar = (numFutureRate - numCurrentRate);
			}
			else if (numUpgradeType == 2) {
				numFutureRate = ns.formulas.calculateMoneyGainRate(nodeStats.level, (nodeStats.ram + 1), nodeStats.cores, ns.getHacknetMultipliers().production);
				retVar = (numFutureRate - numCurrentRate);
			}
			else if (numUpgradeType == 3) {
				numFutureRate = ns.formulas.calculateMoneyGainRate(nodeStats.level, nodeStats.ram, (nodeStats.cores + 1), ns.getHacknetMultipliers().production);
				retVar = (numFutureRate - numCurrentRate);
			}
		}
		else {
			//just re-implement the formula...
			function jankyMoneyGainRate(numLevel, numRam, numCores) {
				return ((1.5 * numLevel) * Math.pow(1.035, numRam - 1) * ((numCores + 5) / 6) * ns.getHacknetMultipliers().production * ns.getBitNodeMultipliers().HacknetNodeMoney);
			}

			numCurrentRate = jankyMoneyGainRate(nodeStats.level, nodeStats.ram, nodeStats.cores);

			if (numUpgradeType == 0) {
				numFutureRate = jankyMoneyGainRate(1, 1, 1);
				retVar = numFutureRate;
			}
			else if (numUpgradeType == 1) {
				numFutureRate = jankyMoneyGainRate((nodeStats.level + 1), nodeStats.ram, nodeStats.cores);
				retVar = (numFutureRate - numCurrentRate);
			}
			else if (numUpgradeType == 2) {
				numFutureRate = jankyMoneyGainRate(nodeStats.level, (nodeStats.ram + 1), nodeStats.cores);
				retVar = (numFutureRate - numCurrentRate);
			}
			else if (numUpgradeType == 3) {
				numFutureRate = jankyMoneyGainRate(nodeStats.level, nodeStats.ram, (nodeStats.cores + 1));
				retVar = (numFutureRate - numCurrentRate);
			}
		}

		return retVar;
	}

	function findMinInArray (arr) {
		ns.print("findMinInArray()");
		var retVar = 0;
		var lowestNumber = arr[0];

		for (var i = 0; i < arr.length; i++) {
			if (arr[i] < lowestNumber) {
				lowestNumber = arr[i];
				retVar = i;
			}
		}

		return retVar;
	}

	function getWaitTime (numUpgradeCost) {
		ns.print("getWaitTime()");
		//a somewhat naive calculation, but should be close enough
		var numSleepTime = ((numUpgradeCost - (ns.getServerMoneyAvailable("home") - bufferMoney)) / ((ns.hacknet.getNodeStats(referenceNode).production * ns.hacknet.numNodes()) * (1 / numHacknetProductionPercent)));
		numSleepTime = Math.ceil(numSleepTime);
		numSleepTime *= 1000;
		numSleepTime += 1000;

		if (numSleepTime > numSleepTimeMax) {
			numSleepTime = numSleepTimeMax;
		}
	}

	while (true) {
		if (ns.hacknet.numNodes() <= 0) {
			ns.print("there are currently no nodes in the hacknet");

			if (ns.hacknet.getPurchaseNodeCost() <= (ns.getServerMoneyAvailable("home") - bufferMoney)) {
				ns.hacknet.purchaseNode();
			}
		}

		//get / keep everything in sync
		for (var i = 1; i < ns.hacknet.numNodes(); i++) {
			while (ns.hacknet.getNodeStats(i).level < ns.hacknet.getNodeStats(referenceNode).level) {
				if (ns.hacknet.getLevelUpgradeCost(i, 1) < (ns.getServerMoneyAvailable("home") - bufferMoney)) {
					ns.hacknet.upgradeLevel(i, 1);
				}
				else {
					await ns.sleep(numSleepInterval);
				}
			}

			while (ns.hacknet.getNodeStats(i).ram < ns.hacknet.getNodeStats(referenceNode).ram) {
				if (ns.hacknet.getRamUpgradeCost(i, 1) < (ns.getServerMoneyAvailable("home") - bufferMoney)) {
					ns.hacknet.upgradeRam(i, 1);
				}
				else {
					await ns.sleep(numSleepInterval);
				}
			}

			while (ns.hacknet.getNodeStats(i).cores < ns.hacknet.getNodeStats(referenceNode).cores) {
				if (ns.hacknet.getCoreUpgradeCost(i, 1) < (ns.getServerMoneyAvailable("home") - bufferMoney)) {
					ns.hacknet.upgradeCore(i, 1);
				}
				else {
					await ns.sleep(numSleepInterval);
				}
			}
		}

		//costs[0] == new node
		//costs[1] == level
		//costs[2] == ram
		//costs[3] == cores
		var costs = [
			ns.hacknet.getPurchaseNodeCost(),
			(ns.hacknet.getLevelUpgradeCost(referenceNode, 1) * ns.hacknet.numNodes()),
			(ns.hacknet.getRamUpgradeCost(referenceNode, 1) * ns.hacknet.numNodes()),
			(ns.hacknet.getCoreUpgradeCost(referenceNode, 1) * ns.hacknet.numNodes())
		];

		if (ns.hacknet.numNodes() >= numMaxNodes) {
			costs[0] = Infinity;
		}

		var cheapestOption = findMinInArray(costs);
		var numCurrentMoney = (ns.getServerMoneyAvailable("home") - bufferMoney);

		//this is still somewhat naive, but should be considerably better than what I had
		//it does not take into account the incremental purchase of upgrades (vs a new node)
		//
		//this is a relative comparison, so whatever is being compared is always baselined
		//against the cheapestOption
		for (var i = 0; i < costs.length; i++) {
			if (i != cheapestOption) {
				var numDeltaTime = getWaitTime(costs[i] - numCurrentMoney) - getWaitTime(costs[cheapestOption] - numCurrentMoney);
				var numDeltaMoney = levelUpgradeProfitDeltaPerSec(i);

				if (i != 0) {
					numDeltaMoney *= ns.hacknet.numNodes();
				}

				var numDeltaProfit = (numDeltaMoney * numDeltaTime);
				var numAdjustedCost = (costs[i] - numDeltaProfit);
				var numProfitabilityRatio = (numDeltaProfit / numAdjustedCost);
				var numCheapestOptionMoney = levelUpgradeProfitDeltaPerSec(cheapestOption);

				if (cheapestOption != 0) {
					numCheapestOptionMoney*= ns.hacknet.numNodes();
				}

				var numCheapestOptionProfitabilityRatio = (numCheapestOptionMoney / costs[cheapestOption]);

				if (numProfitabilityRatio > numCheapestOptionProfitabilityRatio) {
					ns.print("option" + i + " with a profitability ratio of " + numProfitabilityRatio + " is now the best option");
					cheapestOption = i;
				}
			}
		}

		ns.print("costs[0]: " + costs[0]);
		ns.print("costs[1]: " + costs[1]);
		ns.print("costs[2]: " + costs[2]);
		ns.print("costs[3]: " + costs[3]);
		ns.print("the cheapest option is costs[" + findMinInArray(costs) + "]");
		ns.print("the option with the best profitability ratio is costs[" + cheapestOption + "]");

		if (costs[cheapestOption] == Infinity) {
			ns.print("no more upgrades available");
			break;
		}

		if (cheapestOption == 1) {
			costs[cheapestOption] = ns.hacknet.getLevelUpgradeCost(referenceNode, 1);
		}
		else if (cheapestOption == 2) {
			costs[cheapestOption] = ns.hacknet.getRamUpgradeCost(referenceNode, 1);
		}
		else if (cheapestOption == 3) {
			costs[cheapestOption] = ns.hacknet.getCoreUpgradeCost(referenceNode, 1);
		}

		while (costs[cheapestOption] > (ns.getServerMoneyAvailable("home") - bufferMoney)) {
			await ns.sleep(getWaitTime(costs[cheapestOption]));
			//print ("available funds: " + (getServerMoneyAvailable("home") - bufferMoney));
		}

		if (costs[cheapestOption] <= (ns.getServerMoneyAvailable("home") - bufferMoney)) {
			if (cheapestOption == 0) {
				ns.print("purchasing a new node");
				ns.hacknet.purchaseNode();
			}
			else if (cheapestOption == 1) {
				ns.print("purchasing level upgrade");
				ns.hacknet.upgradeLevel(referenceNode, 1);
			}
			else if (cheapestOption == 2) {
				ns.print("purchasing ram upgrade");
				ns.hacknet.upgradeRam(referenceNode, 1);
			}
			else if (cheapestOption == 3) {
				ns.print("purchasing core upgrade");
				ns.hacknet.upgradeCore(referenceNode, 1);
			}
		}

		//to prevent an error
		await ns.sleep(10);
	}
}